#if UNITY_EDITOR && !BALANCY_SERVER
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Balancy.Dictionaries;
using Newtonsoft.Json;
using UnityEditor;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Networking;

namespace Balancy.Editor
{
    public class PluginUtils
    {
        private static string PLUGINS_LOCAL_FOLDER = "Assets/Balancy/";
#if BALANCY_CREATOR
        private static string PLUGINS_ADDRESS_LOCAL => "Assets/plugins.json";
        private static string PLUGINS_ADDRESS_LOCAL_READ => "/plugins.json";
#else
        private static string PLUGINS_ADDRESS_LOCAL => PLUGINS_LOCAL_FOLDER + "Editor/plugins.json";
        private static string PLUGINS_ADDRESS_LOCAL_READ => "/Balancy/Editor/plugins.json";
#endif
        private const string PLUGINS_ADDRESS_ORIGINAL = "/Balancy/Editor/balancy_plugins.json";
        internal static string CODE_GENERATION_PATH => PLUGINS_LOCAL_FOLDER + "AutoGeneratedCode";

#if LOCAL_PLUGINS_TEST
        public const string PLUGINS_ADDRESS_REMOTE = "/balancy_plugins.json";
#else
        public const string PLUGINS_ADDRESS_REMOTE = "config/balancy_plugins.json";
#endif

        private const string CODE_GENERATION_PLUGIN = "Balancy";
        private static string CODE_GENERATION_FILE => PLUGINS_LOCAL_FOLDER + "Scripts/BalancyMain.cs";

        internal static Action<PluginInfo> onUpdatePluginInfo;
        internal static Action<PluginInfo> onRemovePluginInfo;
        internal static Action onRedraw;

        internal class EditorButton
        {
            [JsonProperty("title")]
            public string title;

            [JsonProperty("url")]
            public string Url;
        }

        internal class EditorMessage
        {
            [JsonProperty("text")]
            public string Text;

            [JsonProperty("buttons")]
            public EditorButton[] Buttons;

            [JsonProperty("min_version")]
            private string _minVersionString;

            [JsonProperty("max_version")]
            private string _maxVersionString;

            [JsonIgnore]
            private PluginVersion _minVersion;

            [JsonIgnore]
            private PluginVersion _maxVersion;

            [JsonIgnore]
            public PluginVersion MinVersion
            {
                get
                {
                    if (_minVersion == null && !string.IsNullOrEmpty(_minVersionString))
                        _minVersion = new PluginVersion(_minVersionString);
                    return _minVersion;
                }
            }

            [JsonIgnore]
            public PluginVersion MaxVersion
            {
                get
                {
                    if (_maxVersion == null && !string.IsNullOrEmpty(_maxVersionString))
                        _maxVersion = new PluginVersion(_maxVersionString);
                    return _maxVersion;
                }
            }
        }

        internal class EditorInfo
        {
            [JsonProperty("url")]
            public string DownloadUrl;

            [JsonProperty("version")]
            private string _versionString;

            [JsonProperty("min_version")]
            private string _minVersionString;

            [JsonProperty("message")]
            public EditorMessage Message;

            [JsonIgnore]
            private PluginVersion _version;
            [JsonIgnore]
            private PluginVersion _minVersion;

            [JsonIgnore]
            public PluginVersion Version
            {
                get
                {
                    if (_version == null && !string.IsNullOrEmpty(_versionString))
                        _version = new PluginVersion(_versionString);
                    return _version;
                }
            }

            [JsonIgnore]
            public PluginVersion MinVersion
            {
                get
                {
                    if (_minVersion == null && !string.IsNullOrEmpty(_minVersionString))
                        _minVersion = new PluginVersion(_minVersionString);
                    return _minVersion;
                }
            }
        }

        public class PluginInfoBase
        {
            [JsonProperty("name")]
            public string Name;
            [JsonProperty("version")]
            private string versionString;

            [JsonIgnore]
            private PluginVersion _version;

            [JsonIgnore]
            public PluginVersion Version
            {
                get
                {
                    if (_version == null && !string.IsNullOrEmpty(versionString))
                        _version = new PluginVersion(versionString);
                    return _version;
                }
            }
        }

        internal class DownloadInfo
        {
            [JsonProperty("url")]
            public string Url;
            [JsonProperty("file")]
            public string File;
        }

        public class PluginVersion
        {
            private readonly int Major;
            private readonly int Minor;
            private readonly int Patch;

            public PluginVersion(string version)
            {
                var items = version.Split('.');
                if (items.Length > 0)
                {
                    int.TryParse(items[0], out Major);

                    if (items.Length > 1)
                    {
                        int.TryParse(items[1], out Minor);

                        if (items.Length > 2)
                            int.TryParse(items[2], out Patch);
                    }
                }
            }

            public bool IsHigherOrEqualThan(PluginVersion otherVersion)
            {
                if (otherVersion.Major != Major)
                    return Major > otherVersion.Major;

                if (otherVersion.Minor != Minor)
                    return Minor > otherVersion.Minor;

                return Patch >= otherVersion.Patch;
            }

            public new string ToString()
            {
                return string.Format("{0}.{1}.{2}", Major, Minor, Patch);
            }
        }

        internal class PluginInfo : PluginInfoBase
        {
#pragma warning disable 649
            [JsonProperty("description")]
            public string Description;
            [JsonProperty("can_be_removed")]
            public bool CanBeRemoved;
            [JsonProperty("download")]
            private DownloadInfo[] Download;
            [JsonProperty("defines")]
            private string[] Defines;
            [JsonProperty("dependencies")]
            public PluginInfoBase[] Dependencies;
            [JsonProperty("code")]
            public string Code;
            [JsonProperty("documentation")]
            public string Documentation;
#pragma warning restore 649

            [JsonIgnore]
            public bool Installing;
            [JsonIgnore]
            public float InstallProgress;

            public void RemovePlugin()
            {
                for (int i = 0; i < Download.Length; i++)
                {
                    var path = PLUGINS_LOCAL_FOLDER + Download[i].File;
                    if (File.Exists(path))
                        FileHelper.DeleteFileAtPath(path);
                }

                AssetDatabase.Refresh();

                onRemovePluginInfo?.Invoke(this);
            }

            private void AddDefines()
            {
                if (Defines != null && Defines.Length != 0)
                {
                    var group = BuildPipeline.GetBuildTargetGroup(EditorUserBuildSettings.activeBuildTarget);
                    string defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(group);

                    var defineSymbols = defines
                        .Split(';')
                        .Select(d => d.Trim())
                        .ToList();

                    string definesToAdd = string.Empty;

                    foreach (var newD in Defines)
                    {
                        bool found = defineSymbols.Any(symbol => string.Equals(newD, symbol));

                        if (!found)
                            definesToAdd += ";" + newD;
                    }

                    if (!string.IsNullOrEmpty(definesToAdd))
                    {
                        try
                        {
                            PlayerSettings.SetScriptingDefineSymbolsForGroup(group, defines + definesToAdd);
                        }
                        catch (System.Exception e)
                        {
                            Debug.LogErrorFormat("Could not add plugin define symbols for build group: {0}, {1}", group, e);
                        }
                    }
                }
            }

            public void InstallPlugin()
            {
                EditorCoroutineHelper.Execute(InstallAllFiles(AddDefines));
            }

            IEnumerator InstallAllFiles(UnityAction onComplete)
            {
                Installing = true;

                byte[][] remoteFiles = new byte[Download.Length][];

                var perFileProgress = 1f / Download.Length;

                for (int i = 0; i < Download.Length; i++)
                {
                    using (UnityWebRequest www = UnityWebRequest.Get(Download[i].Url))
                    {
                        yield return www.SendWebRequest();

#if UNITY_2020_1_OR_NEWER
                        if (www.result != UnityWebRequest.Result.Success)
#else
                    if (www.isNetworkError || www.isHttpError)
#endif
                        {
                            EditorUtility.DisplayDialog("Error", www.error, "Ok");
                            yield break;
                        }

                        remoteFiles[i] = www.downloadHandler.data;

                        InstallProgress = (i + 1) * perFileProgress;
                        onRedraw?.Invoke();
                    }
                }

                for (int i = 0; i < Download.Length; i++)
                {
                    var fullPath = PLUGINS_LOCAL_FOLDER + Download[i].File;
                    Balancy.UnityUtils.CheckAndCreateDirectoryForFile(fullPath);
                    File.WriteAllBytes(fullPath, remoteFiles[i]);
                }

                Installing = false;
                onUpdatePluginInfo?.Invoke(this);
                AssetDatabase.Refresh();
                onComplete?.Invoke();
            }

            public void UpdatePlugin(PluginInfo localInfo)
            {
                localInfo.RemovePlugin();
                InstallPlugin();
            }
        }

        internal class PluginsFile
        {
#pragma warning disable 649
            [JsonProperty("editor")]
            public EditorInfo EditorInfo;

            [JsonProperty("plugins")]
            public List<PluginInfo> Plugins;
#pragma warning restore 649

            public PluginInfo GetOrCreatePluginInfo(string name)
            {
                var info = GetPluginInfo(name);
                if (info != null)
                    return info;

                info = new PluginInfo();
                Plugins.Add(info);

                info.Name = name;

                return info;
            }

            public string GetMainCode()
            {
                return GetPluginInfo(CODE_GENERATION_PLUGIN)?.Code;
            }

            public PluginInfo GetPluginInfo(string name)
            {
                foreach (var plugin in Plugins)
                {
                    if (string.Equals(plugin.Name, name))
                        return plugin;
                }

                return null;
            }

            public void UpdatePluginInfo(PluginInfo pluginInfo)
            {
                RemovePluginInfo(pluginInfo);
                Plugins.Add(pluginInfo);
            }

            public void RemovePluginInfo(PluginInfo pluginInfo)
            {
                for (int i = 0; i < Plugins.Count; i++)
                {
                    if (string.Equals(Plugins[i].Name, pluginInfo.Name))
                    {
                        Plugins.RemoveAt(i);
                        break;
                    }
                }
            }

            public void SaveLocally()
            {
                string str = JsonConvert.SerializeObject(this);
                Balancy.UnityUtils.CheckAndCreateDirectoryForFile(PLUGINS_ADDRESS_LOCAL);
                FileHelper.SaveToFilePath(PLUGINS_ADDRESS_LOCAL, str);
                AssetDatabase.Refresh();
            }
        }

        internal static void GenerateCodeForStartFile(PluginsFile plugins, string code)
        {
            string insertString = string.Empty;
            for (int i = 0; i < plugins.Plugins.Count; i++)
            {
                var plugin = plugins.Plugins[i];
                if (plugin.Version == null || string.Equals(plugin.Name, CODE_GENERATION_PLUGIN))
                    continue;

                insertString += plugin.Code;
                if (i != plugins.Plugins.Count - 1)
                    insertString += "\n\t\t\t";
            }

            const string replace = "{0}";

            string newCode = code.Replace(replace, insertString);
            Balancy.UnityUtils.CheckAndCreateDirectoryForFile(CODE_GENERATION_FILE);
            FileHelper.SaveToFilePath(CODE_GENERATION_FILE, newCode);
            AssetDatabase.Refresh();
        }

        public static void GenerateCodeForStartFileExternal()
        {
            var plugins = GetLocalPlugins() ?? GetOriginalPlugins();
            GenerateCodeForStartFile(plugins, plugins.GetPluginInfo(CODE_GENERATION_PLUGIN).Code);
        }

        internal static PluginsFile GetLocalPlugins()
        {
            return ReadPlugin(PLUGINS_ADDRESS_LOCAL_READ);
        }

        internal static PluginsFile GetOriginalPlugins()
        {
            return ReadPlugin(PLUGINS_ADDRESS_ORIGINAL);
        }

        internal static PluginsFile GetRemotePluginsForTest()
        {
            return ReadPlugin(PLUGINS_ADDRESS_REMOTE);
        }

        private static PluginsFile ReadPlugin(string path)
        {
            var finalPath = Application.dataPath + path;
            var allText = File.Exists(finalPath) ? File.ReadAllText(finalPath) : null;
            return string.IsNullOrEmpty(allText) ? null : JsonConvert.DeserializeObject<PluginsFile>(allText);
        }

        public static void UpdateLocalPath(ScriptableObject script)
        {
            PLUGINS_LOCAL_FOLDER = GetLocalPath(script);
        }

        private static string GetLocalPath(ScriptableObject script)
        {
            MonoScript ms = MonoScript.FromScriptableObject(script);
            var scriptFilePath = AssetDatabase.GetAssetPath(ms);

            var scriptFolder = scriptFilePath.Substring(0, scriptFilePath.LastIndexOf("/", StringComparison.Ordinal));
            var balancyFolder = scriptFolder.Substring(0, scriptFolder.LastIndexOf("/", StringComparison.Ordinal) + 1);

            return balancyFolder;
        }
    }
}
#endif